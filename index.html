<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#ffffff"> <link rel="manifest" id="my-manifest">

  <title>PingMe Premium</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    /* --- MODERN CSS VARIABLES & RESET --- */
    :root {
      /* Palette */
      --primary: #FF2D55; 
      --primary-grad: linear-gradient(135deg, #FF2D55 0%, #FF5C8A 100%);
      --bg-body: #F2F2F7;
      --bg-card: #FFFFFF;
      --bg-input: #E9E9EB;
      --text-main: #000000;
      --text-muted: #8E8E93;
      --border: rgba(0,0,0,0.08);
      --glass: rgba(255, 255, 255, 0.95);
      
      /* Theme Color Fixed for Light Mode */
      --theme-color: #ffffff;

      /* Messages */
      --msg-me-bg: var(--primary-grad);
      --msg-me-text: #FFFFFF;
      --msg-you-bg: #E5E5EA;
      --msg-you-text: #000000;
      
      /* Utilities */
      --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
      --shadow-lg: 0 10px 30px rgba(0,0,0,0.12);
      --radius-md: 20px;
      --safe-area-bottom: env(safe-area-inset-bottom, 20px);
      
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }

    /* Fixed Dark Mode Selector */
    html[data-theme="dark"] {
      --bg-body: #000000;
      --bg-card: #1C1C1E;
      --bg-input: #2C2C2E;
      --text-main: #FFFFFF;
      --text-muted: #98989D;
      --border: rgba(255,255,255,0.1);
      --glass: rgba(28, 28, 30, 0.95);
      --msg-you-bg: #2C2C2E;
      --msg-you-text: #FFFFFF;
      --theme-color: #000000; 
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
    
    html, body {
      height: 100%; height: 100dvh;
      margin: 0; padding: 0;
      background: var(--bg-body); color: var(--text-main);
      overflow: hidden;
      position: fixed; width: 100%; font-size: 15px; line-height: 1.4;
      transition: background 0.3s, color 0.3s;
    }

    /* --- PREMIUM LOADER ANIMATION --- */
    .premium-splash-container {
      position: relative; width: 240px; height: 240px;
      display: flex; align-items: center; justify-content: center;
    }
    .splash-text {
      font-size: 32px; font-weight: 900;
      background: var(--primary-grad); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      z-index: 10; letter-spacing: -0.5px;
    }
    .splash-ring {
      position: absolute; border-radius: 50%; border: 3px solid transparent;
      box-shadow: 0 0 20px rgba(255, 45, 85, 0.08);
    }
    .splash-ring:nth-child(1) {
      width: 100%; height: 100%; border-top-color: var(--primary); border-right-color: var(--primary);
      animation: spin-cw 2.5s linear infinite;
    }
    .splash-ring:nth-child(2) {
      width: 75%; height: 75%; border-bottom-color: #FF5C8A; border-left-color: #FF5C8A;
      animation: spin-ccw 2s linear infinite;
    }
    @keyframes spin-cw { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes spin-ccw { 0% { transform: rotate(0deg); } 100% { transform: rotate(-360deg); } }

    .lds-dual-ring { display: inline-block; width: 60px; height: 60px; }
    .lds-dual-ring:after { content: " "; display: block; width: 48px; height: 48px; margin: 6px; border-radius: 50%; border: 5px solid var(--primary); border-color: var(--primary) transparent var(--primary) transparent; animation: lds-dual-ring 1.2s linear infinite; }
    @keyframes lds-dual-ring { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* --- UTILITIES --- */
    .glass-panel {
      background: var(--glass); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
    }
    .hidden { display: none !important; }
    
    /* --- VIEW MANAGEMENT --- */
    .view-section { 
      display: none; flex-direction: column; 
      height: 100%; height: 100dvh; width: 100%; 
      position: absolute; top:0; left:0; background: var(--bg-body);
      overflow: hidden;
    }
    .view-section.active { display: flex; animation: fadeIn 0.3s ease-out; z-index: 10; }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.99); } to { opacity: 1; transform: scale(1); } }

    /* --- INSTALL BANNER --- */
    #install-banner {
        display: none; background: var(--bg-card); padding: 10px 16px; margin: 10px 16px 0;
        border-radius: 16px; box-shadow: var(--shadow-sm); align-items: center; justify-content: space-between;
        border: 1px solid var(--primary); animation: slideDown 0.4s ease;
    }
    @keyframes slideDown { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    /* --- HEADER --- */
    header.app {
      display: flex; align-items: center; justify-content: space-between; 
      padding: 12px 16px; height: 60px; z-index: 50; flex-shrink: 0;
      padding-top: max(12px, env(safe-area-inset-top));
    }
    .header-title { font-weight: 700; font-size: 17px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .icon-btn {
      background: transparent; border: none; color: var(--primary); 
      width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
      transition: background 0.2s; cursor: pointer; padding: 0;
    }
    .icon-btn:active { background: rgba(0,0,0,0.05); }

    /* --- LISTS --- */
    .list-container {
      flex: 1; overflow-y: auto; padding: 10px 16px 100px; -webkit-overflow-scrolling: touch;
    }
    .user-card {
      display: flex; align-items: center; gap: 14px; padding: 12px;
      background: var(--bg-card); border-radius: var(--radius-md); margin-bottom: 10px;
      box-shadow: var(--shadow-sm); transition: transform 0.1s, box-shadow 0.2s;
      cursor: pointer; border: 1px solid transparent; user-select: none;
    }
    .user-card:active, .user-card.long-press-active { transform: scale(0.96); background: var(--bg-input); }
    
    .avatar-wrapper { position: relative; width: 48px; height: 48px; flex-shrink: 0; }
    .avatar { 
      width: 100%; height: 100%; border-radius: 50%; background: var(--bg-input); 
      object-fit: cover; display: flex; align-items: center; justify-content: center;
      font-weight: 700; color: var(--text-muted); font-size: 18px; overflow: hidden;
      border: 1px solid var(--border);
    }
    .avatar img { width: 100%; height: 100%; object-fit: cover; }
    .status-dot { 
      width: 12px; height: 12px; border-radius: 50%; background: #4CD964; 
      position: absolute; bottom: 0; right: 0; border: 2px solid var(--bg-card);
      display: none; box-shadow: 0 0 0 2px var(--bg-card);
    }
    .status-dot.online { display: block; animation: pulse 2s infinite; }
    
    .card-info { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 4px; }
    .card-top { display: flex; justify-content: space-between; align-items: center; }
    .card-name { font-weight: 600; font-size: 16px; color: var(--text-main); }
    .card-time { font-size: 12px; color: var(--text-muted); }
    .card-msg { font-size: 13px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .search-result-card { justify-content: space-between; }
    .btn-msg-action {
        background: var(--primary); color: white; border: none; padding: 6px 14px;
        border-radius: 15px; font-size: 12px; font-weight: 600; cursor: pointer;
    }

    /* --- CHAT AREA FIXED --- */
    main.chat-view {
        flex: 1; display: flex; flex-direction: column; background: var(--bg-body); 
        position: relative; overflow: hidden; width: 100%;
        /* Wallpaper Support */
        background-size: cover; background-position: center; background-repeat: no-repeat;
    }
    
    /* UPDATED MESSAGES AREA FOR DYNAMIC SPACING */
    .messages-area {
        flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; 
        gap: 2px; 
        padding-bottom: 20px; /* Reduced initial padding */
        -webkit-overflow-scrolling: touch;
        scroll-behavior: auto;
        transition: padding-bottom 0.3s ease; /* Smooth transition */
        overflow-x: hidden; /* Prevent horizontal scroll due to swipe */
    }
    /* Dynamic class added via JS when typing */
    .messages-area.typing-active {
        padding-bottom: 80px; /* Expands to fit bubble */
    }

    .date-separator {
        align-self: center; background: rgba(128,128,128,0.25); backdrop-filter: blur(4px); padding: 4px 12px;
        border-radius: 12px; font-size: 11px; font-weight: 600; color: var(--text-main); margin: 16px 0 8px;
    }
    .msg-row { display: flex; width: 100%; margin-bottom: 2px; position: relative; align-items: flex-end;}
    .msg-row.me { justify-content: flex-end; }
    .msg-row.you { justify-content: flex-start; }
    
    .msg-bubble {
      max-width: 75%; padding: 10px 14px; font-size: 15px; position: relative; word-wrap: break-word;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05); cursor: pointer; transition: transform 0.1s; user-select: none;
      touch-action: pan-y; /* Allow vertical scroll, handle horizontal in JS */
    }
    .msg-bubble:active { transform: scale(0.98); }
    .msg-row.me .msg-bubble { background: var(--msg-me-bg); color: var(--msg-me-text); border-radius: 18px 4px 18px 18px; }
    .msg-row.you .msg-bubble { background: var(--msg-you-bg); color: var(--msg-you-text); border-radius: 4px 18px 18px 18px; }
    .msg-bubble img.chat-img { border-radius: 12px; max-width: 100%; display: block; margin-top: 4px; }
    
    /* --- NEW MEDIA STYLES (VIDEO, FILE & AUDIO) --- */
    .msg-bubble video.chat-video { border-radius: 12px; max-width: 100%; display: block; margin-top: 4px; }
    .msg-bubble audio.chat-audio { width: 200px; margin-top: 4px; border-radius: 20px; max-width: 100%; }
    
    .file-attachment {
        display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.1);
        padding: 8px 10px; border-radius: 12px; margin-top: 4px; text-decoration: none; color: inherit;
        transition: background 0.2s;
    }
    .msg-row.me .file-attachment { background: rgba(255,255,255,0.2); }
    .file-attachment:active { opacity: 0.7; }
    .file-icon {
        width: 32px; height: 32px; background: var(--bg-card); color: var(--primary);
        border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 10px;
        flex-shrink: 0; text-transform: uppercase;
    }
    .msg-row.me .file-icon { color: var(--primary); }
    .file-name { font-size: 13px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 140px; }

    .msg-meta { font-size: 9px; margin-top: 4px; opacity: 0.7; text-align: right; display: flex; justify-content: flex-end; align-items: center; gap:3px; }

    .status-tick { font-weight: 900; font-size: 10px; margin-left: 2px; }
    
    /* --- NEW SEEN AVATAR ANIMATION --- */
    .seen-avatar {
        width: 16px; height: 16px; border-radius: 50%;
        margin-left: 4px; border: 1.5px solid var(--bg-body);
        animation: dropIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        object-fit: cover;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    @keyframes dropIn {
        from { opacity: 0; transform: translateY(-10px) scale(0.8); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .heart-reaction {
      position: absolute; bottom: -6px; right: -4px; font-size: 14px; background: #fff; border-radius: 50%;
      width: 22px; height: 22px; display: flex; align-items: center; justify-content: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); z-index: 5;
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      border: 1px solid rgba(0,0,0,0.05);
    }
    @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }

    /* --- TYPING INDICATOR (FIXED POSITIONING) --- */
    .typing-bubble-container {
        position: absolute; 
        /* UPDATED FIX: Anchor to bottom of previous element instead of fixed top pixel */
        top: auto;
        bottom: 100%; 
        left: 20px; 
        z-index: 50;
        display: none; 
        animation: slideUpFade 0.3s ease-out;
        pointer-events: none;
        margin-bottom: 6px; /* Space from input box */
    }
    .typing-bubble-container.active { display: block; }
    @keyframes slideUpFade { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }

    .typing-bubble {
        background: var(--bg-input); padding: 12px 16px; border-radius: 18px 18px 18px 4px;
        box-shadow: var(--shadow-sm); display: flex; gap: 4px; align-items: center; height: 38px;
        border: 1px solid var(--border);
    }
    .dot {
        width: 6px; height: 6px; background: #8E8E93; border-radius: 50%;
        animation: typingBounce 1.4s infinite ease-in-out both;
    }
    .dot:nth-child(1) { animation-delay: -0.32s; }
    .dot:nth-child(2) { animation-delay: -0.16s; }
    @keyframes typingBounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
    
    .chat-input-area {
      position: relative; /* Context for typing bubble */
      flex-shrink: 0; background: var(--glass); backdrop-filter: blur(20px); border-top: 1px solid var(--border);
      padding: 10px 16px; padding-bottom: max(10px, env(safe-area-inset-bottom));
      display: flex; flex-direction: column; gap: 8px; z-index: 60; width: 100%;
    }
    .input-wrapper {
      display: flex; align-items: flex-end; gap: 8px; background: var(--bg-input);
      border-radius: 24px; padding: 6px 6px 6px 12px; border: 1px solid transparent; transition: border 0.2s;
    }
    .input-wrapper:focus-within { border-color: var(--primary); background: var(--bg-card); }
    textarea.chat-box, input.chat-box {
      flex: 1; background: transparent; border: none; font-size: 15px; color: var(--text-main);
      resize: none; max-height: 120px; padding: 10px 0; line-height: 20px;
    }
    .btn-send {
      width: 36px; height: 36px; border-radius: 50%; background: var(--primary); color: white;
      border: none; flex-shrink: 0; display: flex; align-items: center; justify-content: center;
      box-shadow: 0 4px 10px rgba(255, 45, 85, 0.4); transition: transform 0.1s; margin-bottom: 2px;
    }
    .btn-send:active { transform: scale(0.9); }
    
    .reply-preview {
      display: none; align-items: center; justify-content: space-between;
      padding: 8px 12px; background: var(--bg-input); border-radius: 12px; font-size: 12px;
      border-left: 3px solid var(--primary); margin-bottom: 4px;
    }
    .reply-preview.active { display: flex; }

    /* --- UPDATED VOICE RECORDING UI (SONAR & WAVE) --- */
    #recording-overlay {
        position: absolute; inset: 0; background: linear-gradient(90deg, #FF3B30 0%, #FF9500 100%); z-index: 10;
        display: none; align-items: center; justify-content: space-between;
        padding: 0 20px; border-radius: 24px; color: white;
        box-shadow: 0 4px 15px rgba(255, 59, 48, 0.4);
    }
    #recording-overlay.active { display: flex; animation: slideInRight 0.2s ease-out; }
    @keyframes slideInRight { from{transform: translateX(20px); opacity: 0;} to{transform: translateX(0); opacity: 1;} }
    
    .recording-dot {
        width: 12px; height: 12px; border-radius: 50%; background: white;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        animation: pulseWhite 1s infinite;
    }
    @keyframes pulseWhite { 0%{transform:scale(1); opacity:1;} 50%{transform:scale(1.4); opacity:0.7;} 100%{transform:scale(1); opacity:1;} }

    /* Sonar Effect on Mic Button */
    .mic-active { 
        transform: scale(1.3) !important; 
        color: white !important; 
        background: #FF3B30 !important;
        box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7);
        animation: sonarWave 1.5s infinite cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    @keyframes sonarWave {
        0% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7); }
        70% { box-shadow: 0 0 0 20px rgba(255, 59, 48, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0); }
    }

    /* --- BOTTOM NAV --- */
    .bottom-nav {
      position: absolute; bottom: 0; width: 100%; height: calc(60px + env(safe-area-inset-bottom));
      background: var(--glass); backdrop-filter: blur(20px); border-top: 1px solid var(--border);
      display: flex; justify-content: space-around; padding-bottom: env(safe-area-inset-bottom); z-index: 100;
    }
    .nav-item {
      flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: var(--text-muted); gap: 4px; cursor: pointer; transition: color 0.2s;
    }
    .nav-item.active { color: var(--primary); }
    .nav-item svg { width: 24px; height: 24px; }
    .nav-label { font-size: 10px; font-weight: 500; }

    /* --- PROFILE & SETTINGS --- */
    .profile-container { padding: 20px; padding-bottom: 100px; overflow-y: auto; height: 100%; }
    .large-avatar-box {
      width: 100px; height: 100px; border-radius: 50%; margin: 0 auto 16px;
      position: relative; box-shadow: var(--shadow-lg); background: var(--bg-card);
    }
    .large-avatar-img { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }
    .cam-badge {
      position: absolute; bottom: 0; right: 0; background: var(--primary); color: white;
      width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
      border: 3px solid var(--bg-body); cursor: pointer;
    }
    .settings-group {
      background: var(--bg-card); border-radius: 16px; padding: 0 16px; margin-bottom: 20px; box-shadow: var(--shadow-sm);
    }
    .settings-item {
      padding: 16px 0; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border);
    }
    .settings-item:last-child { border-bottom: none; }
    .settings-label { font-size: 15px; font-weight: 500; }
    .settings-input { border: none; background: transparent; text-align: right; font-size: 15px; color: var(--text-muted); width: 60%; }

    .switch { position: relative; width: 50px; height: 30px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; inset: 0; background: #E9E9EB; border-radius: 30px; transition: .4s; cursor: pointer; }
    .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 2px; bottom: 2px; background: white; border-radius: 50%; transition: .4s; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    input:checked + .slider { background: var(--primary); }
    input:checked + .slider:before { transform: translateX(20px); }

    /* --- AUTH --- */
    .auth-wrap {
      padding: 40px 30px; display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100%; text-align: center; overflow-y: auto;
    }
    .auth-card { width: 100%; max-width: 400px; }
    .input-field {
      width: 100%; padding: 16px; margin: 8px 0; border-radius: 16px; border: 1px solid var(--border);
      background: var(--bg-input); color: var(--text-main); font-size: 16px; transition: border 0.2s;
    }
    .input-field:focus { border-color: var(--primary); background: var(--bg-card); }
    .btn-primary {
      width: 100%; padding: 16px; margin-top: 16px; border-radius: 16px; border: none;
      background: var(--primary-grad); color: white; font-size: 16px; font-weight: 600;
      box-shadow: 0 8px 20px rgba(255, 45, 85, 0.25); cursor: pointer; transition: transform 0.1s;
    }
    .btn-primary:active { transform: scale(0.98); }

    /* --- ACTION SHEET --- */
    .overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px);
      z-index: 2000; opacity: 0; visibility: hidden; transition: 0.3s;
      display: flex; align-items: flex-end; justify-content: center;
    }
    .overlay.active { opacity: 1; visibility: visible; }
    .action-sheet {
      width: 100%; max-width: 500px; background: var(--bg-card);
      border-radius: 24px 24px 0 0; padding: 24px; transform: translateY(100%); 
      transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      box-shadow: var(--shadow-lg); display: flex; flex-direction: column; gap: 8px;
    }
    .overlay.active .action-sheet { transform: translateY(0); }
    .sheet-header { text-align: center; margin-bottom: 10px; color: var(--text-muted); font-size: 13px; font-weight: 600; }
    .sheet-btn {
      width: 100%; padding: 16px; border-radius: 16px; border: none; background: var(--bg-input);
      color: var(--text-main); font-size: 16px; font-weight: 600; cursor: pointer;
      display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    .sheet-btn.danger { background: rgba(255, 59, 48, 0.1); color: #FF3B30; }
    .sheet-btn:active { transform: scale(0.98); }

    /* --- TOAST --- */
    .toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-100px);
      background: var(--glass); backdrop-filter: blur(20px); padding: 12px 24px;
      border-radius: 30px; box-shadow: var(--shadow-lg); border: 1px solid var(--border);
      font-weight: 600; color: var(--text-main); z-index: 3000; transition: 0.4s;
      display: flex; align-items: center; gap: 8px;
    }
    .toast.active { transform: translateX(-50%) translateY(0); }

    /* --- LIGHTBOX --- */
    #lightbox { 
      position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 5000; 
      display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: 0.3s; 
    }
    #lightbox.active { opacity: 1; pointer-events: auto; }
    #lightbox img { max-width: 100%; max-height: 100%; transition: transform 0.1s; transform-origin: center; will-change: transform; }
  </style>

  <script>
    const manifestData = {
        "name": "PingMe Premium",
        "short_name": "PingMe",
        "start_url": ".",
        "display": "standalone",
        "background_color": "#ffffff",
        "theme_color": "#FF2D55",
        "icons": [{"src": "https://i.postimg.cc/RZ5FH16z/Gemini-Generated-Image-rgsqsqrgsqsqrgsq-removebg-preview.png","sizes": "192x192","type": "image/png"}]
    };
    const blobManifest = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
    document.getElementById('my-manifest').setAttribute('href', URL.createObjectURL(blobManifest));

    // Service Worker for PWA (Blob URL method preserved for single-file structure)
    const swCode = `
      self.addEventListener('install', (e) => { 
        self.skipWaiting(); 
      });
      self.addEventListener('activate', (e) => { 
        e.waitUntil(self.clients.claim()); 
      });
      self.addEventListener('fetch', (e) => { 
        e.respondWith(
          fetch(e.request)
            .catch(() => caches.match(e.request))
            .then(res => res || new Response("Offline", { status: 503 }))
        );
      });
    `;
    const swBlob = new Blob([swCode], {type: 'application/javascript'});
    const swUrl = URL.createObjectURL(swBlob);

    if ('serviceWorker' in navigator) {
         navigator.serviceWorker.register(swUrl).then((reg) => {
             console.log('SW Registered');
             setInterval(() => { reg.update(); }, 60 * 1000); 
         }).catch(console.error);
    }
  </script>
</head>
<body>

  <audio id="notification-sound" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3" preload="auto" hidden crossorigin="anonymous"></audio>

  <audio id="snd-btn-click" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3" preload="auto" hidden crossorigin="anonymous"></audio>
  
  <audio id="snd-sent" src="https://assets.mixkit.co/active_storage/sfx/1606/1606-preview.mp3" preload="auto" hidden crossorigin="anonymous"></audio>

  <audio id="snd-seen" src="https://assets.mixkit.co/active_storage/sfx/571/571-preview.mp3" preload="auto" hidden crossorigin="anonymous"></audio>

  <audio id="snd-typing-click" src="https://assets.mixkit.co/active_storage/sfx/2364/2364-preview.mp3" preload="auto" hidden crossorigin="anonymous"></audio>

  <audio id="snd-partner-typing" src="https://cdn.freesound.org/previews/240/240566_3905081-lq.mp3" preload="auto" loop hidden crossorigin="anonymous"></audio>

  <audio id="snd-sweet-beep" src="https://assets.mixkit.co/active_storage/sfx/1862/1862-preview.mp3" preload="auto" hidden crossorigin="anonymous"></audio>

  <div id="toastMsg" class="toast">
    <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"></path></svg>
    <span id="toastText">Success</span>
  </div>

  <div id="splash-screen" style="position:fixed;inset:0;background:var(--bg-body);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:opacity 0.5s;">
    <div class="premium-splash-container">
        <div class="splash-ring"></div>
        <div class="splash-ring"></div>
        <div class="splash-text">PingMe</div>
    </div>
  </div>

  <div id="lightbox">
      <button id="lightbox-close" style="position:absolute;top:20px;right:20px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:50%;width:40px;height:40px;font-size:24px;cursor:pointer;z-index:5001;">&times;</button>
      <img id="lightbox-img" src="">
  </div>

  <div id="actionSheetOverlay" class="overlay">
    <div class="action-sheet" id="actionSheetContent"></div>
  </div>

  <div class="wrap" style="height:100%;">
      
      <div id="view-auth" class="view-section active">
          <div class="auth-wrap">
              <div class="auth-card">
                  <img src="https://i.postimg.cc/RZ5FH16z/Gemini-Generated-Image-rgsqsqrgsqsqrgsq-removebg-preview.png" width="80" style="margin-bottom:20px; border-radius:16px; box-shadow: 0 10px 20px rgba(255,45,85,0.2);">
                  <div style="font-size:48px; font-weight:900; margin-bottom:8px; color:var(--primary);">PingMe</div>
                  <p style="color:var(--text-muted); margin-bottom:30px;">Sign in to continue</p>

                  <div id="signup-fields" class="hidden">
                      <input id="auth-name" class="input-field" placeholder="Full Name" />
                  </div>
                  <input id="auth-email" class="input-field" placeholder="Email Address" type="email" />
                  <input id="auth-pass" class="input-field" placeholder="Password (6+ chars)" type="password" />
                  
                  <div id="auth-error" style="color:#FF3B30; font-size:13px; margin:10px 0; display:none;">Error</div>

                  <button id="auth-btn" class="btn-primary">Sign In</button>
                  <div id="forgot-pass-btn" style="margin-top:15px; color:var(--primary); font-weight:600; font-size:13px; cursor:pointer;">Forgot Password?</div>
                  <div id="auth-toggle" style="margin-top:20px; color:var(--text-muted); font-size:14px; cursor:pointer;">Don't have an account? <span style="color:var(--text-main); font-weight:600;">Sign Up</span></div>
              </div>
          </div>
      </div>

      <div id="view-home" class="view-section">
          <header class="app glass-panel">
             <div class="header-title" style="font-size:22px; font-weight:800;">Chats</div>
             <button class="icon-btn" id="profile-header-btn">
                <div class="avatar" style="width:34px; height:34px;">
                    <img id="header-avatar-img" src="" style="display:none;">
                    <span id="header-avatar-text">U</span>
                </div>
             </button>
          </header>
          
          <div id="install-banner">
              <div style="display:flex;align-items:center;gap:10px;">
                  <img src="https://i.postimg.cc/RZ5FH16z/Gemini-Generated-Image-rgsqsqrgsqsqrgsq-removebg-preview.png" width="30" style="border-radius:6px;">
                  <div style="font-weight:600; font-size:13px;">Install App</div>
              </div>
              <button id="install-btn" style="background:var(--primary); color:white; border:none; padding:6px 14px; border-radius:20px; font-size:11px; font-weight:700; cursor:pointer;">Install</button>
          </div>

          <div style="padding: 0 16px; margin-top: 20px; margin-bottom: 10px;">
              <div class="input-wrapper" style="background:var(--bg-input); padding: 8px 12px;">
                  <svg width="18" height="18" fill="none" stroke="var(--text-muted)" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
                  <input id="home-search-input" class="chat-box" placeholder="Search message, name, ID..." style="height:auto; padding:0; margin-left:8px;">
              </div>
          </div>

          <div class="list-container" id="chat-list-container">
              <div style="text-align:center; padding:50px; color:var(--text-muted);">
                  <div class="lds-dual-ring" style="transform:scale(0.5);"></div>
                  <div>Loading Chats...</div>
              </div>
          </div>

          <nav class="bottom-nav">
              <div class="nav-item active" id="nav-chats">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>
                  <span class="nav-label">Chats</span>
              </div>
              <div class="nav-item" id="nav-find">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                  <span class="nav-label">Search</span>
              </div>
              <div class="nav-item" id="nav-profile">
                  <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>
                  <span class="nav-label">Profile</span>
              </div>
          </nav>
      </div>

      <div id="view-find" class="view-section" style="z-index: 20;">
          <header class="app glass-panel">
              <button class="icon-btn" id="back-from-find">
                  <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
              </button>
              <div class="header-title">Find Friends</div>
          </header>
          <div class="profile-container">
             <div class="input-wrapper" style="margin-bottom:20px; background:var(--bg-card); padding:8px 16px;">
                 <input id="search-ping-id" class="chat-box" placeholder="Enter Ping ID (e.g. rahim1234)" style="height:auto;">
                 <button id="search-btn" class="icon-btn" style="background:var(--primary); color:white; width:32px; height:32px;">
                    <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
                 </button>
             </div>
             
             <div id="search-history-section">
                <h4 style="margin:0 0 10px; font-size:13px; color:var(--text-muted); display:flex; justify-content:space-between;">
                    RECENT SEARCHES
                    <span id="clear-history-btn" style="color:#FF3B30; cursor:pointer;">Clear</span>
                </h4>
                <div id="history-list" style="display:flex; gap:15px; overflow-x:auto; padding-bottom:10px;"></div>
             </div>
             
             <div id="search-results" style="margin-top:20px;"></div>
          </div>
      </div>

      <div id="view-chat" class="view-section" style="z-index: 30;">
          <header class="app glass-panel" style="justify-content: flex-start; gap: 10px;">
              <button class="icon-btn" id="chat-back-btn">
                  <svg width="28" height="28" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
              </button>
              
              <div class="avatar" id="chat-header-avatar-container" style="width:36px; height:36px; border:1px solid var(--border);">
                   <img id="chat-header-img" src="" style="display:none;">
                   <span id="chat-header-initial">?</span>
              </div>

              <div id="chat-user-header" style="flex:1; display:flex; flex-direction:column; justify-content:center; align-items:flex-start; cursor:pointer;">
                  <div class="header-title" id="chat-header-name" style="font-size:16px;">User</div>
                  <div id="chat-header-status" style="font-size:11px; color:var(--text-muted); font-weight:500;">Offline</div>
              </div>
          </header>
          
          <main class="chat-view">
              <div class="messages-area" id="messages"></div>
              
              <footer class="chat-input-area">
                <div id="typing-bubble" class="typing-bubble-container">
                  <div class="typing-bubble">
                      <div class="dot"></div>
                      <div class="dot"></div>
                      <div class="dot"></div>
                  </div>
                </div>

                <div id="blocked-banner" style="background:#FFE5E5; color:#FF3B30; padding:10px; text-align:center; border-radius:12px; font-size:13px; display:none; font-weight:600; margin-bottom:5px;"></div>
                
                <div id="input-area-wrapper">
                    <div class="reply-preview" id="replyPreview">
                        <div style="flex:1; overflow:hidden;">
                            <span style="color:var(--primary); font-weight:700;" id="replyToName">Name</span>
                            <div style="font-size:11px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" id="replyTextPreview">Text</div>
                        </div>
                        <button id="cancelReply" style="background:none; border:none; color:var(--text-muted); font-size:20px;">&times;</button>
                    </div>

                    <div class="input-wrapper">
                        <input type="file" id="img-input" accept="image/*" hidden />
                        <input type="file" id="video-input" accept="video/*" hidden />
                        <input type="file" id="file-input" accept=".pdf,.doc,.docx,.txt,.zip" hidden />
                        
                        <div id="recording-overlay">
                            <div style="display:flex;align-items:center;gap:10px;">
                                <div class="recording-dot"></div>
                                <span id="recording-timer" style="font-weight:700; font-variant-numeric:tabular-nums; font-size:14px;">0:00</span>
                            </div>
                            <div style="font-size:11px; font-weight:600; opacity:0.9; text-transform:uppercase; letter-spacing:0.5px;">Recording... Release to Send</div>
                        </div>

                        <button class="icon-btn" id="img-btn" style="width:32px; height:32px; color:var(--text-muted);">
                            <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        </button>
                        <textarea id="msg-input" class="chat-box" rows="1" placeholder="iMessage"></textarea>
                        
                        <button class="icon-btn" id="mic-btn" style="width:32px; height:32px; margin-right:4px; transition:all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);">
                            <svg width="22" height="22" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
                        </button>

                        <button class="btn-send" id="send-btn" style="display:none;">
                            <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14M12 5l7 7-7 7" /></svg>
                        </button>
                    </div>
                </div>
              </footer>
          </main>
      </div>

      <div id="view-profile" class="view-section" style="z-index: 20;">
          <header class="app glass-panel">
              <button class="icon-btn" id="back-from-profile">
                  <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
              </button>
              <div class="header-title">My Profile</div>
          </header>
          
          <div class="profile-container">
              <div class="large-avatar-box">
                  <img id="profile-img-preview" class="large-avatar-img" src="" onclick="if(this.src) viewImg(this.src)">
                  <div id="profile-initial-preview" style="width:100%; height:100%; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:40px; font-weight:700; color:var(--text-muted);">U</div>
                  <label for="profile-file-input" class="cam-badge">
                      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                  </label>
                  <input type="file" id="profile-file-input" hidden accept="image/*">
              </div>
              
              <div style="text-align:center; margin-bottom:20px;">
                  <h2 id="current-user-display-name" style="margin:0; font-size:22px;">Loading...</h2>
                  <div id="my-ping-id" style="color:var(--text-muted); font-size:13px; margin-top:4px;">@...</div>
              </div>

              <div class="settings-group">
                  <div class="settings-item">
                      <span class="settings-label">Dark Mode</span>
                      <label class="switch">
                          <input type="checkbox" id="theme-toggle">
                          <span class="slider"></span>
                      </label>
                  </div>
                  <div class="settings-item">
                      <span class="settings-label">Sound Effects</span>
                      <label class="switch">
                          <input type="checkbox" id="sound-toggle" checked>
                          <span class="slider"></span>
                      </label>
                  </div>
                  <div class="settings-item" id="wallpaper-btn" style="cursor:pointer;">
                      <span class="settings-label">Chat Wallpaper</span>
                      <div style="display:flex;align-items:center;gap:6px;">
                           <span style="color:var(--text-muted); font-size:13px;">Change</span>
                           <svg width="16" height="16" fill="none" stroke="var(--text-muted)" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" /></svg>
                      </div>
                  </div>
                  <input type="color" id="bg-color-input" hidden>
                  <input type="file" id="bg-img-input" hidden accept="image/*">
              </div>

              <div class="settings-group">
                  <div class="settings-item">
                      <span class="settings-label">Display Name</span>
                      <input id="edit-name" class="settings-input" placeholder="Your Name">
                  </div>
                  <div class="settings-item">
                      <span class="settings-label">Bio</span>
                      <input id="edit-bio" class="settings-input" placeholder="Add a bio...">
                  </div>
                  <div class="settings-item">
                      <span class="settings-label">Phone</span>
                      <input id="edit-phone" class="settings-input" type="tel" placeholder="Phone Number">
                  </div>
                  <div class="settings-item">
                      <span class="settings-label">Email</span>
                      <input id="edit-email" class="settings-input" disabled style="opacity:0.6;">
                  </div>
              </div>
              
              <button id="save-profile-btn" class="btn-primary" style="margin-top:0;">Save Changes</button>

              <div class="settings-group" style="margin-top: 20px; border: 1px solid rgba(255, 59, 48, 0.2); background: rgba(255, 59, 48, 0.05);">
                  <div class="settings-item" id="logout-btn" style="justify-content: center; cursor: pointer;">
                      <span style="color: #FF3B30; font-weight: 600;">Sign Out</span>
                  </div>
              </div>
          </div>
      </div>

      <div id="view-friend-profile" class="view-section" style="z-index: 40;">
          <header class="app glass-panel">
              <button class="icon-btn" id="back-from-friend-profile">
                  <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
              </button>
              <div class="header-title">Friend's Profile</div>
          </header>
          
          <div class="profile-container">
              <div class="large-avatar-box" style="margin-bottom:10px;">
                  <img id="friend-img-preview" class="large-avatar-img" src="" onclick="if(this.src) viewImg(this.src)">
                  <div id="friend-initial-preview" style="width:100%; height:100%; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:40px; font-weight:700; color:var(--text-muted);">U</div>
              </div>
              
              <div style="text-align:center; margin-bottom:30px;">
                  <h2 id="friend-display-name" style="margin:0; font-size:22px;">Name</h2>
                  <div id="friend-ping-id" style="color:var(--text-muted); font-size:13px; margin-top:4px;">@...</div>
              </div>

              <div class="settings-group">
                  <div class="settings-item">
                      <span class="settings-label">Bio</span>
                      <span id="friend-bio" style="color:var(--text-muted);">...</span>
                  </div>
                  <div class="settings-item">
                      <span class="settings-label">Email</span>
                      <span id="friend-email" style="color:var(--text-muted);">...</span>
                  </div>
              </div>

              <button id="friend-block-btn" class="btn-primary" style="background:#FF3B30; margin-top:0;">Block User</button>
          </div>
      </div>

  </div> 

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut, updateProfile, sendEmailVerification, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, getDocs, updateDoc, query, collection, where, onSnapshot, serverTimestamp, increment, orderBy, limit, addDoc, arrayUnion, arrayRemove, deleteDoc, writeBatch, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyAOEmgVj-OzfVaZsNOn47WTdaCrb5h8h_s",
      authDomain: "ping-me-app-475d1.firebaseapp.com",
      databaseURL: "https://ping-me-app-475d1-default-rtdb.firebaseio.com",
      projectId: "ping-me-app-475d1",
      storageBucket: "ping-me-app-475d1.firebasestorage.app",
      messagingSenderId: "41337345094",
      appId: "1:41337345094:web:0a6f31fd1dd0a1f6026647",
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    
    // --- ENABLE OFFLINE PERSISTENCE (SERVER CONNECTIVITY UPGRADE) ---
    enableIndexedDbPersistence(db).catch((err) => {
        if (err.code == 'failed-precondition') {
            console.log('Multiple tabs open, persistence can only be enabled in one tab at a a time.');
        } else if (err.code == 'unimplemented') {
            console.log('The current browser does not support all of the features required to enable persistence');
        }
    });

    const USERS_PATH = `artifacts/${firebaseConfig.projectId}/public/data/users`;
    const CHATS_PATH = `artifacts/${firebaseConfig.projectId}/public/data/chat_rooms`;

    // --- STATE ---
    let currentUser = null, currentUserData = null;
    let currentChatId = null, currentPartnerId = null, currentPartnerData = null;
    let unsubscribeChats, unsubscribeMsgs, unsubscribeRoom, unsubscribePartnerStatus;
    let isLoginMode = true, isSigningUp = false;
    let replyTo = null, currentMsgId = null;
    let globalNotificationUnsubscribe = null;
    let typingTimeout = null, isTyping = false;
    let isSoundEnabled = true; // Sound State
    let msgLimit = 20; // Pagination limit
    
    // Background Connectivity Handles
    let backgroundDisconnectTimeout = null;
    let wakeLock = null;

    // --- AUDIO RECORDING STATE ---
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let recordStartTime = 0;
    let recordInterval = null;

    // --- SOUND SYSTEM & AUDIO UNLOCKER (UPDATED) ---
    let audioUnlocked = false;
    
    function initAudio() {
        if(audioUnlocked) return;
        ['notification-sound', 'snd-btn-click', 'snd-sent', 'snd-seen', 'snd-typing-click', 'snd-partner-typing', 'snd-sweet-beep'].forEach(id => {
            const el = document.getElementById(id);
            if(el) { el.volume = 0; el.play().then(() => { el.pause(); el.currentTime = 0; }).catch(() => {}); }
        });
        audioUnlocked = true;
        document.removeEventListener('click', initAudio);
        document.removeEventListener('touchstart', initAudio);
    }
    
    document.addEventListener('click', initAudio);
    document.addEventListener('touchstart', initAudio);

    const playSound = (id, loop=false) => {
        if(!isSoundEnabled) return; // Check Global Sound State
        const audio = document.getElementById(id);
        if (audio) {
            if(loop && !audio.paused) return; // Don't restart loop if already playing
            audio.loop = loop;
            if(id === 'snd-seen') audio.volume = 0.4;
            else if(id === 'snd-partner-typing') audio.volume = 0.6;
            else if(id === 'snd-typing-click') audio.volume = 0.3; // Softer key click
            else if(id === 'snd-sweet-beep') audio.volume = 0.7; // Sweet beep volume
            else audio.volume = 0.5;
            
            audio.currentTime = 0; 
            audio.play().catch(e => console.log("Sound blocked:", e));
        }
    };
    
    const stopSound = (id) => {
        const audio = document.getElementById(id);
        if(audio) { audio.pause(); audio.currentTime = 0; }
    };

    // --- CACHE & INSTANT LOAD LOGIC ---
    function checkCacheOnStartup() {
        const cachedUser = localStorage.getItem('cached_user_data');
        if (cachedUser) {
            try {
                currentUserData = JSON.parse(cachedUser);
                if(currentUserData.uid) {
                    // Pre-render Home UI immediately
                    document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
                    get('view-home').classList.add('active');
                    get('nav-chats').classList.add('active');
                    updateHeaderUI();
                    
                    const cachedChats = localStorage.getItem('cached_chat_list');
                    if(cachedChats) {
                        const rooms = JSON.parse(cachedChats);
                        renderChatList(rooms); // Render cached list
                    }
                    // Hide Splash immediately if cache exists
                    const splash = get('splash-screen');
                    splash.style.opacity = 0;
                    setTimeout(() => splash.classList.add('hidden'), 500);
                }
            } catch(e) { console.error("Cache parse error", e); }
        }
    }
    // Call immediately before Firebase auth triggers
    checkCacheOnStartup();

    // --- HELPER: TIME AGO (UPDATED FOR REAL STATUS) ---
    function formatTimeAgo(dateInput) {
        if(!dateInput) return '';
        // Handle Firestore Timestamp or Date String or Date Object
        let date = dateInput;
        if(dateInput.seconds) date = new Date(dateInput.seconds * 1000);
        else if(typeof dateInput === 'string') date = new Date(dateInput);

        const seconds = Math.floor((new Date() - date) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "y ago";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "mo ago";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "d ago";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "h ago";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "m ago";
        return "Just now";
    }

    // --- UI HELPERS ---
    const get = (id) => document.getElementById(id);
    const showToast = (msg) => {
        const t = get('toastMsg'); get('toastText').textContent = msg;
        t.classList.add('active'); setTimeout(() => t.classList.remove('active'), 2500);
    };
    
    // --- SCROLL HELPER ---
    const scrollToBottom = () => {
        const list = get('messages');
        requestAnimationFrame(() => {
            list.scrollTop = list.scrollHeight;
        });
        setTimeout(() => {
             list.scrollTop = list.scrollHeight;
        }, 100);
    };

    const showView = (id) => {
        document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
        get(id).classList.add('active');
        if(id === 'view-home' || id === 'view-find' || id === 'view-profile') {
           document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
           if(id === 'view-home') get('nav-chats').classList.add('active');
           if(id === 'view-find') get('nav-find').classList.add('active');
           if(id === 'view-profile') get('nav-profile').classList.add('active');
        }
        
        // Handle Wake Lock for Chat View
        if (id === 'view-chat') requestWakeLock();
        else releaseWakeLock();
    };

    // --- DARK MODE LOGIC (FIXED) ---
    function initTheme() {
        const savedTheme = localStorage.getItem('theme');
        if(savedTheme === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
            get('theme-toggle').checked = true;
        } else {
            document.documentElement.removeAttribute('data-theme');
            get('theme-toggle').checked = false;
        }

        // Init Sound State
        const savedSound = localStorage.getItem('sound_enabled');
        if(savedSound === 'false') {
            isSoundEnabled = false;
            get('sound-toggle').checked = false;
        } else {
            isSoundEnabled = true;
            get('sound-toggle').checked = true;
        }
        
        // Init Wallpaper
        initWallpaper();
    }
    
    // --- WALLPAPER LOGIC ---
    function initWallpaper() {
        const savedBg = localStorage.getItem('chat_wallpaper');
        const mainView = get('view-chat').querySelector('main');
        
        if (savedBg) {
            if(savedBg.startsWith('#') || savedBg.startsWith('rgb')) {
                // Solid Color
                mainView.style.backgroundImage = 'none';
                mainView.style.background = savedBg;
            } else {
                // Image (Data URL)
                mainView.style.background = 'none'; // clear
                mainView.style.backgroundImage = `url(${savedBg})`;
                mainView.style.backgroundSize = 'cover';
                mainView.style.backgroundPosition = 'center';
            }
        } else {
            // Reset to default css var
            mainView.style.background = '';
            mainView.style.backgroundImage = '';
        }
    }
    
    get('wallpaper-btn').onclick = () => {
        openActionSheet([
            { text: "Choose Solid Color", action: () => { get('bg-color-input').click(); hideActionSheet(); } },
            { text: "Upload Image", action: () => { get('bg-img-input').click(); hideActionSheet(); } },
            { text: "Reset to Default", class: "danger", action: () => { 
                localStorage.removeItem('chat_wallpaper'); 
                initWallpaper();
                showToast("Wallpaper Reset");
                hideActionSheet();
            }},
            { text: "Cancel", action: hideActionSheet }
        ]);
    };
    
    get('bg-color-input').addEventListener('input', (e) => {
        const color = e.target.value;
        localStorage.setItem('chat_wallpaper', color);
        initWallpaper();
    });
    
    get('bg-img-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        
        if(file.size > 2 * 1024 * 1024) {
            alert("Image too large (Max 2MB for wallpaper)");
            return;
        }

        const reader = new FileReader();
        reader.onload = (ev) => {
             const dataUrl = ev.target.result;
             try {
                 localStorage.setItem('chat_wallpaper', dataUrl);
                 initWallpaper();
                 showToast("Wallpaper Updated");
             } catch(err) {
                 alert("Image too large to save. Try a smaller image.");
             }
        };
        reader.readAsDataURL(file);
        // clear input
        get('bg-img-input').value = '';
    });

    
    get('theme-toggle').addEventListener('change', (e) => {
        if(e.target.checked) {
            document.documentElement.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
        } else {
            document.documentElement.removeAttribute('data-theme');
            localStorage.setItem('theme', 'light');
        }
    });

    // Sound Toggle Listener
    get('sound-toggle').addEventListener('change', (e) => {
        isSoundEnabled = e.target.checked;
        localStorage.setItem('sound_enabled', isSoundEnabled);
        showToast(isSoundEnabled ? "Sounds On" : "Sounds Off");
    });

    // --- HOME SEARCH LOGIC (NEW) ---
    get('home-search-input').addEventListener('input', (e) => {
        const term = e.target.value.toLowerCase();
        const cards = document.querySelectorAll('#chat-list-container .user-card');
        
        cards.forEach(card => {
            const name = card.querySelector('.card-name').textContent.toLowerCase();
            const msg = card.querySelector('.card-msg').textContent.toLowerCase();
            const meta = (card.getAttribute('data-search-meta') || '').toLowerCase(); // Hidden data (PingID, etc)
            
            if(name.includes(term) || msg.includes(term) || meta.includes(term)) {
                card.style.display = 'flex';
            } else {
                card.style.display = 'none';
            }
        });
    });

    // --- PINCH TO ZOOM IMAGE VIEWER LOGIC ---
    const lightboxImg = get('lightbox-img');
    const lightbox = get('lightbox');
    let scale = 1, pointX = 0, pointY = 0, startX = 0, startY = 0, isDragging = false, startDist = 0;

    function resetZoom() {
        scale = 1; pointX = 0; pointY = 0;
        lightboxImg.style.transform = `translate(0px, 0px) scale(1)`;
    }

    window.viewImg = (src) => { 
        lightboxImg.src = src; 
        resetZoom();
        lightbox.classList.add('active'); 
    };
    get('lightbox-close').onclick = () => get('lightbox').classList.remove('active');

    lightbox.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault(); 
            startDist = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
        } else if (e.touches.length === 1) {
            startX = e.touches[0].pageX - pointX;
            startY = e.touches[0].pageY - pointY;
            isDragging = true;
        }
    });

    lightbox.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dist = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
            const delta = dist / startDist;
            scale = Math.min(Math.max(1, scale * delta), 4);
            startDist = dist;
            lightboxImg.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
        } else if (e.touches.length === 1 && isDragging && scale > 1) {
            pointX = e.touches[0].pageX - startX;
            pointY = e.touches[0].pageY - startY;
            lightboxImg.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
        }
    });

    lightbox.addEventListener('touchend', () => {
        isDragging = false;
        if (scale < 1) resetZoom();
    });

    function requestNotificationPermission() {
        if ("Notification" in window) {
            if (Notification.permission !== "granted" && Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") console.log("Notification permission granted!");
                });
            }
        }
    }

    // --- WAKE LOCK API (KEEPS SCREEN ON) ---
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator) {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => {
                    // console.log('Screen Wake Lock released');
                });
            }
        } catch (err) {
            // Wake Lock is optional enhancement
            console.log(`${err.name}, ${err.message}`);
        }
    }
    
    function releaseWakeLock() {
        if(wakeLock) {
            wakeLock.release().then(() => wakeLock = null);
        }
    }
    
    // Re-request wake lock if visibility changes back to visible
    document.addEventListener('visibilitychange', async () => {
        if (wakeLock !== null && document.visibilityState === 'visible') {
            await requestWakeLock();
        }
    });

    // --- AUTHENTICATION ---
    onAuthStateChanged(auth, async (user) => {
        const splash = get('splash-screen');
        if (user) {
            initTheme(); // Ensure theme loads on login
            if (!user.emailVerified && !isSigningUp) {
                await signOut(auth);
                showToast("Please verify your email.");
                showView('view-auth'); splash.style.opacity = 0; setTimeout(()=>splash.classList.add('hidden'),500);
                return;
            }
            if(isSigningUp) return;
            currentUser = user;
            
            // Check cache again to be sure, or fetch fresh
            if(!currentUserData) await loadUserProfile(user.uid);
            else loadUserProfile(user.uid); // Fetch fresh in background
            
            showView('view-home');
            loadChatList();
            updatePresence('online');
            requestNotificationPermission(); 
            listenGlobalMessages();
            splash.style.opacity = 0; setTimeout(()=>splash.classList.add('hidden'),500);
        } else {
            currentUser = null; currentUserData = null;
            localStorage.removeItem('cached_user_data');
            localStorage.removeItem('cached_chat_list');
            initTheme(); // Ensure theme loads even if logged out
            showView('view-auth');
            splash.style.opacity = 0; setTimeout(()=>splash.classList.add('hidden'),500);
        }
    });

    get('auth-toggle').addEventListener('click', () => {
        isLoginMode = !isLoginMode;
        get('signup-fields').classList.toggle('hidden');
        get('auth-btn').textContent = isLoginMode ? 'Sign In' : 'Sign Up';
        get('auth-toggle').innerHTML = isLoginMode ? `Don't have an account? <span style="color:var(--text-main); font-weight:600;">Sign Up</span>` : `Already have an account? <span style="color:var(--text-main); font-weight:600;">Sign In</span>`;
    });

    get('auth-btn').addEventListener('click', async () => {
        const email = get('auth-email').value.trim();
        const pass = get('auth-pass').value.trim();
        const name = get('auth-name').value.trim();
        const errBox = get('auth-error');
        
        if(!email || !pass) return (errBox.textContent = "All fields required", errBox.style.display = 'block');
        
        get('auth-btn').textContent = "Please wait...";
        get('auth-btn').disabled = true;
        
        try {
            if(isLoginMode) {
                await signInWithEmailAndPassword(auth, email, pass);
            } else {
                if(!name) throw new Error("Name required");
                isSigningUp = true;
                const cred = await createUserWithEmailAndPassword(auth, email, pass);
                
                const cleanName = name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().substring(0, 4);
                const randomId = cleanName + Math.floor(1000 + Math.random() * 9000);
                
                const newUser = {
                    uid: cred.user.uid, displayName: name, email: email,
                    pingId: randomId,
                    photoURL: null, bio: '', phone: '', createdAt: serverTimestamp(),
                    status: 'offline', blockedUsers: []
                };
                await setDoc(doc(db, USERS_PATH, cred.user.uid), newUser);
                await updateProfile(cred.user, { displayName: name });
                await sendEmailVerification(cred.user);
                await signOut(auth);
                isSigningUp = false;
                alert("Account created! Check email to verify.");
                location.reload();
            }
        } catch(e) {
            errBox.textContent = e.message;
            errBox.style.display = 'block';
            get('auth-btn').textContent = isLoginMode ? 'Sign In' : 'Sign Up';
            get('auth-btn').disabled = false;
        }
    });

    get('forgot-pass-btn').onclick = async () => {
        const email = get('auth-email').value;
        if(!email) return showToast("Enter your email address");
        try { await sendPasswordResetEmail(auth, email); showToast("Reset link sent"); } 
        catch(e) { showToast(e.message); }
    };

    // --- USER PROFILE & DATA ---
    async function loadUserProfile(uid) {
        // Try getting fresh data
        const snap = await getDoc(doc(db, USERS_PATH, uid));
        if (snap.exists()) {
             currentUserData = snap.data();
             // Save to cache
             localStorage.setItem('cached_user_data', JSON.stringify(currentUserData));
        } else {
            const baseName = currentUser.displayName ? currentUser.displayName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().substring(0, 4) : 'user';
            const fallbackId = baseName + Math.floor(1000 + Math.random() * 9000);
            
            currentUserData = { uid: uid, displayName: currentUser.displayName, blockedUsers: [], pingId: fallbackId };
            await setDoc(doc(db, USERS_PATH, uid), currentUserData);
        }
        updateHeaderUI();
    }

    function updateHeaderUI() {
        if(!currentUserData) return;
        const name = currentUserData.displayName || 'User';
        const photo = currentUserData.photoURL;
        if(photo) { get('header-avatar-img').src=photo; get('header-avatar-img').style.display='block'; get('header-avatar-text').style.display='none'; }
        else { get('header-avatar-img').style.display='none'; get('header-avatar-text').textContent=name[0].toUpperCase(); get('header-avatar-text').style.display='block'; }
        get('current-user-display-name').textContent = name;
        get('my-ping-id').textContent = '@' + currentUserData.pingId;
        get('edit-name').value = name;
        get('edit-bio').value = currentUserData.bio || '';
        get('edit-phone').value = currentUserData.phone || '';
        get('edit-email').value = currentUser.email;
        if(photo) { get('profile-img-preview').src = photo; get('profile-img-preview').style.display='block'; get('profile-initial-preview').style.display='none'; }
    }

    // --- NAVIGATION ---
    get('profile-header-btn').onclick = () => showView('view-profile');
    get('nav-chats').onclick = () => showView('view-home');
    get('nav-find').onclick = () => { showView('view-find'); loadSearchHistory(); };
    get('nav-profile').onclick = () => showView('view-profile');
    get('back-from-find').onclick = () => showView('view-home');
    get('back-from-profile').onclick = () => showView('view-home');
    get('chat-back-btn').onclick = () => {
        showView('view-home');
        if(unsubscribeMsgs) unsubscribeMsgs();
        if(unsubscribeRoom) unsubscribeRoom();
        
        // Stop typing sound when leaving chat
        stopSound('snd-partner-typing');
    };
    
    get('logout-btn').onclick = async () => { 
        updatePresence('offline'); 
        await signOut(auth); 
        window.location.reload(); 
    };
    
    get('back-from-friend-profile').onclick = () => showView('view-chat');
    
    get('chat-user-header').onclick = async () => {
        showView('view-friend-profile');
        let fullData = currentPartnerData;
        try {
            const snap = await getDoc(doc(db, USERS_PATH, currentPartnerId));
            if (snap.exists()) {
                fullData = snap.data();
                currentPartnerData = { ...currentPartnerData, ...fullData };
            }
        } catch(e) { console.log("Could not fetch full profile"); }

        get('friend-display-name').textContent = fullData.displayName;
        get('friend-ping-id').textContent = '@' + (fullData.pingId || 'unknown');
        get('friend-bio').textContent = fullData.bio || 'No bio available';
        get('friend-email').textContent = fullData.email || 'Hidden';
        
        const img = get('friend-img-preview');
        const txt = get('friend-initial-preview');
        if(fullData.photoURL) { img.src=fullData.photoURL; img.style.display='block'; txt.style.display='none'; }
        else { img.style.display='none'; txt.style.display='flex'; txt.textContent = (fullData.displayName||'U')[0]; }

        const isBlocked = currentUserData.blockedUsers?.includes(currentPartnerId);
        const btn = get('friend-block-btn');
        btn.textContent = isBlocked ? "Unblock User" : "Block User";
        btn.onclick = () => toggleBlock(currentPartnerId, !isBlocked);
    };

    async function toggleBlock(uid, shouldBlock) {
        const ref = doc(db, USERS_PATH, currentUser.uid);
        if(shouldBlock) {
            if(!currentUserData.blockedUsers) currentUserData.blockedUsers = [];
            currentUserData.blockedUsers.push(uid);
            await updateDoc(ref, { blockedUsers: arrayUnion(uid) });
            showToast("User Blocked");
        } else {
            currentUserData.blockedUsers = currentUserData.blockedUsers.filter(x => x !== uid);
            await updateDoc(ref, { blockedUsers: arrayRemove(uid) });
            showToast("User Unblocked");
        }
        const btn = get('friend-block-btn');
        if(currentPartnerId === uid && btn) btn.textContent = shouldBlock ? "Unblock User" : "Block User";
        if(currentPartnerId === uid && get('view-chat').classList.contains('active')) updateChatUIForBlocks(currentPartnerData);
        loadChatList();
        // Update cache
        localStorage.setItem('cached_user_data', JSON.stringify(currentUserData));
    }

    // --- CHAT ROOM LOGIC ---
    async function openChat(partnerId, partnerInfo) {
        currentPartnerId = partnerId;
        currentPartnerData = partnerInfo || { displayName: 'User', photoURL: null };
        const ids = [currentUser.uid, currentPartnerId].sort();
        currentChatId = ids.join('_');

        get('chat-header-name').textContent = currentPartnerData.displayName;
        const img = get('chat-header-img');
        const txt = get('chat-header-initial');
        if(currentPartnerData.photoURL) { 
            img.src = currentPartnerData.photoURL; img.style.display = 'block'; txt.style.display = 'none'; 
        } else { 
            img.style.display = 'none'; txt.style.display = 'flex'; txt.textContent = (currentPartnerData.displayName || 'U')[0]; 
        }
        
        get('chat-header-status').textContent = 'Connecting...';
        showView('view-chat');
        
        msgLimit = 20; // Reset pagination limit on new chat
        loadMessages(currentChatId);
        listenToRoom(currentChatId);

        const chatRef = doc(db, CHATS_PATH, currentChatId);
        try {
            const snap = await getDoc(chatRef);
            if (!snap.exists()) {
                await setDoc(chatRef, {
                    participants: [currentUser.uid, currentPartnerId],
                    participantInfo: {
                        [currentUser.uid]: { displayName: currentUserData.displayName, photoURL: currentUserData.photoURL },
                        [currentPartnerId]: { displayName: currentPartnerData.displayName, photoURL: currentPartnerData.photoURL }
                    },
                    updatedAt: serverTimestamp()
                });
            } else {
                // Ensure participantInfo is up to date when opening
                // Only update my info here, partner info updates via their profile changes
                const data = snap.data();
                const myInfo = data.participantInfo ? data.participantInfo[currentUser.uid] : null;
                if(!myInfo || myInfo.displayName !== currentUserData.displayName || myInfo.photoURL !== currentUserData.photoURL) {
                     await updateDoc(chatRef, {
                        [`participantInfo.${currentUser.uid}`]: { 
                            displayName: currentUserData.displayName, 
                            photoURL: currentUserData.photoURL 
                        }
                     });
                }
            }
        } catch(e) { console.error(e); }
    }
    window.openChat = openChat;

    function listenToRoom(rid) {
        if(unsubscribeRoom) unsubscribeRoom();
        if(unsubscribePartnerStatus) unsubscribePartnerStatus();
        
        const rRef = doc(db, CHATS_PATH, rid);
        updateDoc(rRef, { hiddenFor: arrayRemove(currentUser.uid) }).catch(()=>{});

        // Listen for Partner Typing & Room Updates (Name changes)
        unsubscribeRoom = onSnapshot(rRef, (snap) => {
            if(!snap.exists()) return;
            const data = snap.data();
            
            // --- REAL-TIME NAME UPDATE IN CHAT HEADER ---
            // Check if partner's info updated in the chat room document
            if(data.participantInfo && data.participantInfo[currentPartnerId]) {
                 const newInfo = data.participantInfo[currentPartnerId];
                 // Update global var
                 currentPartnerData.displayName = newInfo.displayName;
                 currentPartnerData.photoURL = newInfo.photoURL;
                 
                 // Update UI
                 get('chat-header-name').textContent = newInfo.displayName;
                 const img = get('chat-header-img');
                 const txt = get('chat-header-initial');
                 if(newInfo.photoURL) { 
                    img.src = newInfo.photoURL; img.style.display = 'block'; txt.style.display = 'none'; 
                 } else { 
                    img.style.display = 'none'; txt.style.display = 'flex'; txt.textContent = (newInfo.displayName || 'U')[0]; 
                 }
            }

            // Show bubble if partner is typing
            const isPartnerTyping = data.typing && data.typing[currentPartnerId];
            const bubble = get('typing-bubble');
            const msgArea = get('messages');

            if(isPartnerTyping) {
                bubble.classList.add('active');
                // Dynamic spacing activation
                msgArea.classList.add('typing-active');
                scrollToBottom();
                playSound('snd-partner-typing', true); 
            } else {
                bubble.classList.remove('active');
                // Dynamic spacing deactivation
                msgArea.classList.remove('typing-active');
                stopSound('snd-partner-typing');
            }
        });

        // --- UPDATED LOGIC FOR REAL-TIME STATUS ACCURACY ---
        unsubscribePartnerStatus = onSnapshot(doc(db, USERS_PATH, currentPartnerId), (snap) => {
             if(snap.exists()) {
                 const u = snap.data();
                 const statusEl = get('chat-header-status');
                 
                 // Logic to determine if truly online based on heartbeat (2-3 min threshold)
                 const now = new Date();
                 const lastActive = u.lastActive ? (u.lastActive.seconds ? new Date(u.lastActive.seconds * 1000) : new Date(u.lastActive)) : new Date(0);
                 const secondsDiff = (now - lastActive) / 1000;
                 
                 // Strict Check: Must be 'online' AND heartbeat within last 3 minutes (180s)
                 const isReallyOnline = u.status === 'online' && secondsDiff < 180; 

                 if(isReallyOnline) { 
                     statusEl.textContent = 'Active Now'; 
                     statusEl.style.color = '#4CD964'; 
                 }
                 else { 
                     statusEl.style.color = 'var(--text-muted)';
                     if (u.lastActive) statusEl.textContent = "Last seen " + formatTimeAgo(u.lastActive);
                     else statusEl.textContent = 'Offline'; 
                 }
                 updateChatUIForBlocks(u);
             }
        });
    }

    // --- TYPING HANDLER ---
    const msgInput = get('msg-input');
    async function updateTypingStatus(status) {
        if(!currentChatId) return;
        try {
            await updateDoc(doc(db, CHATS_PATH, currentChatId), {
                [`typing.${currentUser.uid}`]: status
            });
        } catch(e) { console.log("Typing error", e); }
    }

    msgInput.addEventListener('keydown', () => {
        // --- NEW SOUND: KEY CLICK ---
        playSound('snd-typing-click');
    });

    msgInput.addEventListener('input', () => {
        // If there's text, show send button, hide mic
        const hasText = msgInput.value.trim().length > 0;
        get('mic-btn').style.display = hasText ? 'none' : 'flex';
        get('send-btn').style.display = hasText ? 'flex' : 'none';

        if(!isTyping) {
            isTyping = true;
            updateTypingStatus(true);
        }
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            isTyping = false;
            updateTypingStatus(false);
        }, 2000); 
    });

    function updateChatUIForBlocks(partnerUser) {
        const banner = get('blocked-banner');
        const inputArea = get('input-area-wrapper');
        
        if (partnerUser.blockedUsers?.includes(currentUser.uid)) {
             banner.textContent = "You have been blocked by this user."; 
             banner.style.display = 'block'; inputArea.style.display = 'none';
        } else if (currentUserData.blockedUsers?.includes(currentPartnerId)) {
             banner.innerHTML = `You blocked this user. <span style="text-decoration:underline; cursor:pointer;" onclick="window.quickUnblock()">Unblock</span>`; 
             banner.style.display = 'block'; inputArea.style.display = 'none';
             window.quickUnblock = () => toggleBlock(currentPartnerId, false);
        } else {
             banner.style.display = 'none'; inputArea.style.display = 'block';
        }
    }

    async function toggleLike(rid, mid, currentLikes) {
        const uid = currentUser.uid;
        if(currentLikes && currentLikes.includes(uid)) await updateDoc(doc(db, CHATS_PATH, rid, 'messages', mid), { likes: arrayRemove(uid) });
        else await updateDoc(doc(db, CHATS_PATH, rid, 'messages', mid), { likes: arrayUnion(uid) });
    }

    // --- CHAT LIST (UPDATED WITH LOCAL CACHE & META DATA) ---
    function renderChatList(rooms) {
        const list = get('chat-list-container');
        list.innerHTML = '';
        
        if(!currentUserData) return; // Wait for user data

        rooms.forEach(room => {
            const pid = room.participants.find(id => id !== currentUserData.uid);
            // Safety check if partner ID exists
            if (!pid) return;

            // Use info stored in room document if available (faster & synced), else fallback
            const info = room.participantInfo?.[pid] || { displayName: 'User', photoURL: null };
            
            let lastTxt = room.lastMessage?.text || 'No messages';
            if(room.lastMessage?.type === 'image') lastTxt = ' Photo';
            if(room.lastMessage?.type === 'video') lastTxt = ' Video';
            if(room.lastMessage?.type === 'file') lastTxt = ' File';
            if(room.lastMessage?.type === 'audio') lastTxt = ' Voice Message';
            if(room.lastMessage?.type === 'deleted') lastTxt = ' Message deleted';

            // Handle timestamp format (Firestore vs Local Storage)
            let time = '';
            if(room.lastMessage?.timestamp) {
                let d;
                if(room.lastMessage.timestamp.seconds) d = new Date(room.lastMessage.timestamp.seconds * 1000);
                else d = new Date(room.lastMessage.timestamp);
                time = d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
            }
            
            const card = document.createElement('div');
            card.className = 'user-card';
            // Attach ID to card for search
            card.setAttribute('data-uid', pid);
            
            card.innerHTML = `
               <div class="avatar-wrapper">
                  <div class="avatar">${info.photoURL ? `<img src="${info.photoURL}">` : (info.displayName?info.displayName[0].toUpperCase():'U')}</div>
                  <div class="status-dot" id="dot-${room.id}"></div>
               </div>
               <div class="card-info">
                  <div class="card-top"><span class="card-name">${info.displayName}</span><span class="card-time">${time}</span></div>
                  <div class="card-msg">${lastTxt}</div>
               </div>
            `;
            
            const isBlocked = currentUserData.blockedUsers?.includes(pid);
            const blockText = isBlocked ? "Unblock User" : "Block User";
            
            addLongPress(card, () => {
                openActionSheet([
                     { text: "Delete Chat (For me)", class: "danger", action: () => deleteChatForMe(room.id) },
                     { text: blockText, class: isBlocked ? "" : "danger", action: () => { toggleBlock(pid, !isBlocked); hideActionSheet(); } },
                     { text: "Cancel", action: hideActionSheet }
                ]);
            }, () => openChat(pid, info));

            list.appendChild(card);
            
            // Fetch status and extra data for search (PingID, Phone)
            // Also triggers a passive update if name changed in User DB but not Room DB
            getDoc(doc(db, USERS_PATH, pid)).then(s => {
                if(s.exists()) {
                    const u = s.data();
                    
                    // --- REAL-TIME LIST NAME SYNC CHECK ---
                    // If name in Users collection differs from Room collection cache, update card text immediately
                    if(u.displayName !== info.displayName) {
                         const nameEl = card.querySelector('.card-name');
                         if(nameEl) nameEl.textContent = u.displayName;
                    }

                    // --- SEARCH LIST STATUS CHECK ---
                    const now = new Date();
                    const lastActive = u.lastActive ? (u.lastActive.seconds ? new Date(u.lastActive.seconds * 1000) : new Date(u.lastActive)) : new Date(u.lastActive);
                    const isActuallyOnline = u.status === 'online' && (now - lastActive)/1000 < 180;
                    
                    if(isActuallyOnline) {
                        const dot = get(`dot-${room.id}`);
                        if(dot) dot.classList.add('online');
                    }
                    // Attach meta data for search
                    const metaString = `${u.pingId || ''} ${u.email || ''} ${u.phone || ''}`;
                    card.setAttribute('data-search-meta', metaString);
                }
            }).catch(e=>{});
        });

        if(rooms.length === 0) list.innerHTML = `<div style="text-align:center; padding:50px 20px; color:var(--text-muted);">No chats.<br>Go to <b>Search</b> to find friends.</div>`;
    }

    function loadChatList() {
        if(unsubscribeChats) unsubscribeChats();
        const ref = collection(db, CHATS_PATH);
        unsubscribeChats = onSnapshot(ref, (snapshot) => {
            const rooms = [];
            snapshot.forEach(d => {
                const room = d.data();
                if(room.participants && room.participants.includes(currentUser.uid)) {
                    if(room.hiddenFor && room.hiddenFor.includes(currentUser.uid)) return;
                    if(room.lastMessage && room.lastMessage.senderId !== currentUser.uid && room.lastMessage.status === 'sent') {
                        updateDoc(doc(db, CHATS_PATH, d.id), { 'lastMessage.status': 'delivered' });
                    }
                    rooms.push({ id: d.id, ...room });
                }
            });
            rooms.sort((a,b) => (b.updatedAt?.seconds || 0) - (a.updatedAt?.seconds || 0));

            // Save to LocalStorage for instant load next time
            localStorage.setItem('cached_chat_list', JSON.stringify(rooms));
            
            // Render UI
            renderChatList(rooms);
            
            // Re-apply search filter if there's text in the box (in case of updates)
            const currentSearch = get('home-search-input').value;
            if(currentSearch) {
                 const event = new Event('input');
                 get('home-search-input').dispatchEvent(event);
            }
        });
    }

    // --- CHAT ROOM MESSAGES (UPDATED PAGINATION & ORDERING) ---
    function loadMessages(rid, isLoadMore = false) {
        if(unsubscribeMsgs) unsubscribeMsgs();
        
        // QUERY: Get latest [msgLimit] messages, Ordered DESC (Newest First)
        // We will reverse client side to show Oldest -> Newest
        const ref = collection(db, CHATS_PATH, rid, 'messages');
        const q = query(ref, orderBy('timestamp', 'desc'), limit(msgLimit));
        
        const list = get('messages');
        
        // Save previous scroll height to maintain position on load more
        let prevScrollHeight = 0;
        if(isLoadMore) prevScrollHeight = list.scrollHeight;
        
        let isFirstLoad = true;
        
        unsubscribeMsgs = onSnapshot(q, (snap) => {
            const wasAtBottom = (list.scrollHeight - list.scrollTop) <= (list.clientHeight + 150);
            
            // "SEEN" Sound Logic: Check for changes in existing messages that become seen
            if (!isFirstLoad && !isLoadMore) {
                snap.docChanges().forEach(change => {
                    if (change.type === 'modified') {
                        const d = change.doc.data();
                        // If I sent the message, and it just turned to 'seen', play sound
                        if (d.senderId === currentUser.uid && d.status === 'seen') {
                            playSound('snd-seen'); // --- NEW SOUND: DING ---
                        }
                    }
                    // --- NEW SWEET BEEP LOGIC FOR INCOMING MESSAGES ---
                    if (change.type === 'added') {
                        const d = change.doc.data();
                        // If message is NOT from me (from friend)
                        if (d.senderId !== currentUser.uid) {
                            playSound('snd-sweet-beep'); // Play Sweet Chime
                        }
                    }
                });
            }
            
            list.innerHTML = '';
            const msgs = [];
            snap.forEach(d => msgs.push({id: d.id, ...d.data()}));
            
            // Reverse array because query was DESC, but we render ASC (Top to Bottom)
            msgs.reverse();
            
            let lastDate = null;
            
            msgs.forEach((m, i) => {
                if(m.deletedFor && m.deletedFor.includes(currentUser.uid)) return;

                if(m.senderId !== currentUser.uid && m.status !== 'seen') {
                    updateDoc(doc(db, CHATS_PATH, rid, 'messages', m.id), { status: 'seen' });
                }

                const date = m.timestamp ? new Date(m.timestamp.seconds * 1000) : new Date();
                const dStr = date.toDateString();
                if(dStr !== lastDate) {
                    list.innerHTML += `<div class="date-separator">${dStr}</div>`;
                    lastDate = dStr;
                }

                const isMe = m.senderId === currentUser.uid;
                const row = document.createElement('div');
                row.className = `msg-row ${isMe ? 'me' : 'you'}`;
                
                let content = m.text;
                if(m.type === 'image') content = `<img src="${m.text}" class="chat-img" onclick="window.viewImg('${m.text}')" onload="if(${isFirstLoad} || ${wasAtBottom}) scrollToBottom()">`;
                else if(m.type === 'video') content = `<video src="${m.text}" class="chat-video" controls playsinline></video>`;
                else if(m.type === 'audio') content = `<audio src="${m.text}" class="chat-audio" controls controlsList="nodownload"></audio>`;
                else if(m.type === 'file') {
                    const ext = m.fileName ? m.fileName.split('.').pop().toUpperCase() : 'FILE';
                    content = `<a href="${m.text}" download="${m.fileName || 'file'}" class="file-attachment">
                        <div class="file-icon">${ext}</div>
                        <div class="file-name">${m.fileName || 'Document'}</div>
                    </a>`;
                }

                if(m.type === 'deleted') { content = '<span style="font-style:italic; opacity:0.6;"> Message deleted</span>'; }
                
                let replyHTML = '';
                if(m.replyTo) {
                    replyHTML = `<div style="border-left:2px solid var(--primary); padding-left:6px; margin-bottom:4px; font-size:11px; opacity:0.8;">
                       <div style="font-weight:700">${m.replyTo.name}</div>
                       <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis">${m.replyTo.text}</div>
                    </div>`;
                }
                
                const isLiked = m.likes && m.likes.length > 0;
                const heartHTML = isLiked ? `<div class="heart-reaction"></div>` : '';

                let statusHTML = '';
                if(isMe && m.type !== 'deleted') {
                    if(m.status === 'seen') {
                         // --- NEW SEEN AVATAR LOGIC ---
                         const pPic = currentPartnerData.photoURL;
                         if(pPic) {
                             statusHTML = `<img src="${pPic}" class="seen-avatar" alt="Seen">`;
                         } else {
                             const init = (currentPartnerData.displayName || 'U')[0].toUpperCase();
                             statusHTML = `<div class="seen-avatar" style="background:var(--text-muted); display:inline-flex; align-items:center; justify-content:center; color:white; font-size:8px;">${init}</div>`;
                         }
                    }
                    else if (m.status === 'delivered') statusHTML = '<span class="status-tick"></span>';
                    else statusHTML = '<span class="status-tick"></span>';
                }

                row.innerHTML = `
                   <div class="msg-bubble">
                      ${replyHTML}
                      ${content}
                      ${heartHTML}
                      <div class="msg-meta">
                        ${date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
                        ${statusHTML}
                      </div>
                   </div>
                `;
                
                const bubble = row.querySelector('.msg-bubble');
                bubble.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    if(m.type === 'deleted') return;
                    toggleLike(rid, m.id, m.likes);
                });
                
                // --- NEW SWIPE TO REPLY ---
                addSwipeToReply(bubble, m);

                // LONG PRESS LOGIC
                addLongPress(bubble, () => {
                    if(m.type === 'deleted') return;
                    
                    const opts = [];
                    // 1. Reply
                    opts.push({ text: "Reply", action: () => initReply(m) });

                    // 2. Copy/View
                    if(m.type === 'text') {
                        opts.push({ text: "Copy Text", action: () => { 
                            navigator.clipboard.writeText(m.text); 
                            showToast("Copied"); 
                            hideActionSheet(); 
                        }});
                    } else if (m.type === 'image') {
                         opts.push({ text: "View Image", action: () => { 
                            viewImg(m.text);
                            hideActionSheet(); 
                        }});
                    }
                    
                    // 3. Unsend (Sender only)
                    if(isMe) {
                        opts.push({ text: "Unsend (Everyone)", class:"danger", action: () => deleteMsg(rid, m.id, 'everyone') });
                    }

                    // 4. Delete for Me
                    opts.push({ text: "Delete for Me", class:"danger", action: () => deleteMsg(rid, m.id, 'me') });

                    // 5. Cancel
                    opts.push({ text: "Cancel", action: hideActionSheet });
                    
                    openActionSheet(opts);
                });
                
                list.appendChild(row);
            });
            
            // SCROLL POSITION HANDLING
            if (isLoadMore) {
                // Restore scroll position to where user was
                list.scrollTop = list.scrollHeight - prevScrollHeight;
            } else if (isFirstLoad || wasAtBottom) {
                 scrollToBottom();
            }
            isFirstLoad = false;
        });

        // INFINITE SCROLL LISTENER
        list.onscroll = () => {
           // If scrolled to top AND we have loaded exactly the limit (meaning there might be more)
           if(list.scrollTop === 0 && list.children.length >= msgLimit) {
               msgLimit += 20; // Increase limit
               loadMessages(rid, true); // Reload with flag to preserve position
           }
        };
    }

    // --- MESSAGE SENDING ---
    function initReply(m) {
        let txt = m.text;
        if(m.type === 'image') txt = ' Photo';
        else if(m.type === 'video') txt = ' Video';
        else if(m.type === 'file') txt = ' File';
        else if(m.type === 'audio') txt = ' Voice Message';
        
        replyTo = { id: m.id, text: txt, name: m.senderId===currentUser.uid?'You':currentPartnerData.displayName };
        get('replyToName').textContent = replyTo.name;
        get('replyTextPreview').textContent = replyTo.text;
        get('replyPreview').classList.add('active');
        get('msg-input').focus();
        hideActionSheet();
    }
    get('cancelReply').onclick = () => { replyTo = null; get('replyPreview').classList.remove('active'); };

    async function sendMsg(txt, type='text', fileName=null) {
        if(!txt) return;

        const list = get('messages');
        const tempRow = document.createElement('div');
        tempRow.className = 'msg-row me'; 
        const tempId = 'temp_' + Date.now();
        tempRow.id = tempId;

        let displayContent = txt;
        if(type === 'image') displayContent = `<img src="${txt}" class="chat-img" style="opacity: 0.7;">`; 
        else if(type === 'video') displayContent = `<video src="${txt}" class="chat-video" style="opacity:0.7;"></video>`;
        else if(type === 'audio') displayContent = `<div style="padding:10px;">Sending Voice...</div>`;
        else if(type === 'file') displayContent = `<div class="file-attachment" style="opacity:0.7;"><div class="file-icon">...</div><div class="file-name">${fileName}</div></div>`;

        let replyMarkup = '';
        if(replyTo) {
             replyMarkup = `<div style="border-left:2px solid var(--primary); padding-left:6px; margin-bottom:4px; font-size:11px; opacity:0.8;">
                 <div style="font-weight:700">${replyTo.name}</div>
                 <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis">${replyTo.text}</div>
             </div>`;
        }
        tempRow.innerHTML = `<div class="msg-bubble">${replyMarkup}${displayContent}<div class="msg-meta">Sending...<span class="status-tick" style="opacity:0.5"></span></div></div>`;
        list.appendChild(tempRow);
        scrollToBottom(); 

        try {
            let initialStatus = 'sent';
            const partnerSnap = await getDoc(doc(db, USERS_PATH, currentPartnerId));
            if(partnerSnap.exists() && partnerSnap.data().status === 'online') initialStatus = 'delivered';

            const payload = {
                senderId: currentUser.uid, text: txt, type: type,
                status: initialStatus, deletedFor: [], likes: [], timestamp: serverTimestamp(),
                fileName: fileName // Added filename field
            };
            if(replyTo) { payload.replyTo = replyTo; get('cancelReply').click(); }
            
            await addDoc(collection(db, CHATS_PATH, currentChatId, 'messages'), payload);
            await setDoc(doc(db, CHATS_PATH, currentChatId), {
                participants: [currentUser.uid, currentPartnerId],
                participantInfo: { 
                    [currentUser.uid]: { displayName: currentUserData.displayName, photoURL: currentUserData.photoURL },
                    [currentPartnerId]: { displayName: currentPartnerData.displayName, photoURL: currentPartnerData.photoURL }
                },
                lastMessage: payload, updatedAt: serverTimestamp(), hiddenFor: arrayRemove(currentPartnerId)
            }, {merge: true});
            
            // --- NEW SOUND: SENT PING ---
            playSound('snd-sent');

            clearTimeout(typingTimeout);
            isTyping = false;
            updateTypingStatus(false);

        } catch (error) {
            console.error("Message failed:", error);
            const errRow = document.getElementById(tempId);
            if(errRow) {
                const meta = errRow.querySelector('.msg-meta');
                if(meta) meta.innerHTML = '<span style="color:#FF3B30; font-weight:bold;">Error </span>';
                showToast("Message failed to send");
            }
        }
    }

    get('send-btn').onclick = () => { 
        const t = get('msg-input').value.trim(); 
        if(t) { 
            playSound('snd-btn-click'); // --- NEW SOUND: BUTTON CLICK ---
            sendMsg(t); 
            get('msg-input').value=''; 
            get('msg-input').focus(); 
            // Reset Mic Button
            get('mic-btn').style.display = 'flex';
            get('send-btn').style.display = 'none';
        } 
    };

    get('msg-input').addEventListener('focus', () => { setTimeout(scrollToBottom, 300); });
    get('msg-input').addEventListener('keydown', (e) => {
        if(e.key === 'Enter' && !e.shiftKey) { 
            e.preventDefault(); 
            get('send-btn').click(); 
        }
    });
    
    // --- ATTACHMENT HANDLING ---
    get('img-btn').onclick = () => {
        openActionSheet([
            { text: "Photo", action: () => { get('img-input').click(); hideActionSheet(); } },
            { text: "Video", action: () => { get('video-input').click(); hideActionSheet(); } },
            { text: "Document", action: () => { get('file-input').click(); hideActionSheet(); } },
            { text: "Cancel", action: hideActionSheet }
        ]);
    };

    // Helper for file reading
    const handleFileSelect = (file, type) => {
        if(!file) return;
        // Check size (Limit to 750KB because Firestore doc max is 1MB and Base64 increases size by ~33%)
        if(file.size > 750 * 1024) {
            alert("File is too large for free server. Please select a file smaller than 750KB.");
            return;
        }

        showToast("Processing...");
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (ev) => {
            const dataUrl = ev.target.result;
            // For images, we compress as before
            if(type === 'image') {
                const img = new Image(); img.src = dataUrl;
                img.onload = async () => {
                    const cvs = document.createElement('canvas');
                    const scale = Math.min(800/img.width, 800/img.height, 1);
                    cvs.width = img.width*scale; cvs.height = img.height*scale;
                    cvs.getContext('2d').drawImage(img,0,0,cvs.width,cvs.height);
                    sendMsg(cvs.toDataURL('image/jpeg', 0.7), 'image');
                };
            } else {
                // For video/files, send raw base64
                sendMsg(dataUrl, type, file.name);
            }
        };
    };

    get('img-input').onchange = (e) => { handleFileSelect(e.target.files[0], 'image'); get('img-input').value=''; };
    get('video-input').onchange = (e) => { handleFileSelect(e.target.files[0], 'video'); get('video-input').value=''; };
    get('file-input').onchange = (e) => { handleFileSelect(e.target.files[0], 'file'); get('file-input').value=''; };

    // --- VOICE RECORDING LOGIC (HOLD TO RECORD) ---
    const micBtn = get('mic-btn');
    const recordingOverlay = get('recording-overlay');
    const timerDisplay = get('recording-timer');

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                if(event.data.size > 0) audioChunks.push(event.data);
            };

            mediaRecorder.start();
            isRecording = true;
            
            // UI Updates for Recording
            micBtn.classList.add('mic-active');
            recordingOverlay.classList.add('active');
            
            // Haptic Feedback (if supported)
            if(navigator.vibrate) navigator.vibrate(100);
            
            // Timer Logic
            recordStartTime = Date.now();
            timerDisplay.textContent = '0:00';
            recordInterval = setInterval(() => {
                const diff = Math.floor((Date.now() - recordStartTime) / 1000);
                const m = Math.floor(diff / 60);
                const s = diff % 60;
                timerDisplay.textContent = `${m}:${s.toString().padStart(2, '0')}`;
                
                // Safety: Stop after 60s
                if(diff >= 60) stopRecordingAndSend(); 
            }, 1000);
            
            playSound('snd-typing-click'); // Start sound

        } catch (err) {
            console.error(err);
            alert("Microphone permission denied.");
        }
    }

    function stopRecordingAndSend() {
        if (!mediaRecorder || !isRecording) return;
        
        mediaRecorder.stop();
        isRecording = false;
        clearInterval(recordInterval);
        
        // UI Updates
        micBtn.classList.remove('mic-active');
        recordingOverlay.classList.remove('active');

        mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            
            // Prevent accidental short taps
            if (Date.now() - recordStartTime < 1000) {
                showToast("Hold longer to record");
                return;
            }

            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = () => {
                const base64Audio = reader.result;
                sendMsg(base64Audio, 'audio');
            };
        };
        
        // Stop all tracks to release mic
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
    }

    // Touch Events for Mobile (Hold)
    micBtn.addEventListener('touchstart', (e) => {
        e.preventDefault(); 
        startRecording();
    });

    micBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopRecordingAndSend();
    });

    // Mouse Events for Desktop (Click and Hold)
    micBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startRecording();
    });

    micBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopRecordingAndSend();
    });
    
    // Safety if mouse leaves button while holding
    micBtn.addEventListener('mouseleave', (e) => {
        if(isRecording) stopRecordingAndSend();
    });


    // --- HELPER: ACTION SHEET ---
    function openActionSheet(buttons) {
        const sheet = get('actionSheetContent');
        sheet.innerHTML = '<div class="sheet-header">Select Option</div>';
        buttons.forEach(b => {
            const btn = document.createElement('button');
            btn.className = `sheet-btn ${b.class || ''}`;
            btn.textContent = b.text;
            btn.onclick = b.action;
            sheet.appendChild(btn);
        });
        get('actionSheetOverlay').classList.add('active');
    }
    window.hideActionSheet = () => get('actionSheetOverlay').classList.remove('active');
    get('actionSheetOverlay').onclick = (e) => { if(e.target === get('actionSheetOverlay')) hideActionSheet(); };

    // --- SWIPE TO REPLY FUNCTION ---
    function addSwipeToReply(element, messageData) {
        let startX = 0;
        let startY = 0;
        let isSwiping = false;
        let currentX = 0;

        element.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            element.style.transition = 'none'; // Instant move
        }, {passive: true});

        element.addEventListener('touchmove', (e) => {
            const x = e.touches[0].clientX;
            const y = e.touches[0].clientY;
            const deltaX = x - startX;
            const deltaY = y - startY;

            // Check if user is scrolling vertically (ignore swipe)
            if (Math.abs(deltaY) > Math.abs(deltaX)) return;

            // Only swipe right (deltaX > 0)
            if (deltaX > 0) {
                // If moving more than 10px, prevent long press from firing
                if(deltaX > 10) element.classList.remove('long-press-active'); 

                if (e.cancelable) e.preventDefault(); // Stop default browser back gestures
                
                isSwiping = true;
                // Add resistance (logarithmic feel) to not pull too far
                currentX = Math.min(deltaX, 100); 
                element.style.transform = `translateX(${currentX}px)`;
            }
        }, {passive: false});

        element.addEventListener('touchend', (e) => {
            if (!isSwiping) return;

            // Smooth snap back
            element.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            element.style.transform = 'translateX(0)';

            // Threshold to trigger reply
            if (currentX > 60) {
                 if(navigator.vibrate) navigator.vibrate(50);
                 initReply(messageData);
            }

            isSwiping = false;
            currentX = 0;
        });
    }

    function addLongPress(el, onLong, onClick) {
        let timer;
        const start = () => { timer = setTimeout(() => { if(navigator.vibrate) navigator.vibrate(50); el.classList.add('long-press-active'); onLong(); }, 500); };
        const end = () => { clearTimeout(timer); el.classList.remove('long-press-active'); };
        el.addEventListener('touchstart', start, {passive:true}); el.addEventListener('touchend', end); el.addEventListener('touchmove', end);
        el.addEventListener('mousedown', start); el.addEventListener('mouseup', end);
        if(onClick) el.addEventListener('click', onClick);
    }
    
    // --- SEARCH PAGE (GLOBAL FIND) ---
    get('search-btn').onclick = async () => {
        const pid = get('search-ping-id').value.trim();
        const res = get('search-results'); res.innerHTML = 'Searching...';
        
        const q = query(collection(db, USERS_PATH), where("pingId", "==", pid));
        const snap = await getDocs(q);
        
        res.innerHTML = '';
        if(snap.empty) return (res.innerHTML = '<div style="text-align:center;color:var(--text-muted);">User not found.<br>Check PingID exactly (e.g. rahim1234)</div>');
        
        snap.forEach(d => {
            const u = d.data();
            if(u.uid === currentUser.uid) return (res.innerHTML = '<div style="text-align:center;">That\'s your ID!</div>');
            
            const div = document.createElement('div');
            div.className = 'user-card search-result-card';
            div.innerHTML = `
                <div style="display:flex; align-items:center; gap:12px;">
                    <div class="avatar" style="width:40px; height:40px;">
                        ${u.photoURL ? `<img src="${u.photoURL}">` : u.displayName[0].toUpperCase()}
                    </div>
                    <div style="font-weight:600; font-size:15px;">${u.displayName}</div>
                </div>
                <button class="btn-msg-action">Message</button>
            `;
            div.onclick = () => { addToHistory(u); openChat(u.uid, u); };
            res.appendChild(div);
        });
    };
    function addToHistory(u) {
        const k = `history_${currentUser.uid}`;
        let h = JSON.parse(localStorage.getItem(k)||'[]');
        h = h.filter(x => x.uid !== u.uid); h.unshift(u);
        localStorage.setItem(k, JSON.stringify(h.slice(0,5)));
    }
    window.loadSearchHistory = () => {
        const k = `history_${currentUser.uid}`;
        const h = JSON.parse(localStorage.getItem(k)||'[]');
        const list = get('history-list'); list.innerHTML = '';
        h.forEach(u => {
            const el = document.createElement('div');
            el.innerHTML = `<div class="avatar" style="width:50px;height:50px;margin-bottom:4px;">${u.displayName[0]}</div><div style="font-size:10px;text-align:center;">${u.displayName.split(' ')[0]}</div>`;
            el.onclick = () => openChat(u.uid, u);
            list.appendChild(el);
        });
        get('search-history-section').style.display = h.length ? 'block' : 'none';
    };
    get('clear-history-btn').onclick = () => { localStorage.removeItem(`history_${currentUser.uid}`); loadSearchHistory(); };

    // --- PROFILE SAVE & REAL-TIME SYNC ---
    get('save-profile-btn').onclick = async () => {
        const btn = get('save-profile-btn'); 
        btn.textContent = 'Saving...';
        const newName = get('edit-name').value;
        const newBio = get('edit-bio').value;
        const newPhone = get('edit-phone').value;
        const newPhoto = currentUserData.photoURL; // already updated by image input

        // 1. Update User Document
        await updateDoc(doc(db, USERS_PATH, currentUser.uid), {
            displayName: newName, bio: newBio, phone: newPhone
        });
        
        // 2. Update all Chat Rooms where I am a participant (For real-time name change for others)
        const q = query(collection(db, CHATS_PATH), where("participants", "array-contains", currentUser.uid));
        const snaps = await getDocs(q);
        
        // Use batch for better performance (though standard loop works too)
        const batch = writeBatch(db);
        snaps.forEach(d => {
            const ref = doc(db, CHATS_PATH, d.id);
            // Update the specific key for my UID in the participantInfo map
            batch.update(ref, {
                [`participantInfo.${currentUser.uid}.displayName`]: newName,
                [`participantInfo.${currentUser.uid}.photoURL`]: newPhoto
            });
        });
        await batch.commit();

        // Update local state and cache
        currentUserData.displayName = newName;
        currentUserData.bio = newBio;
        currentUserData.phone = newPhone;
        localStorage.setItem('cached_user_data', JSON.stringify(currentUserData));
        
        updateHeaderUI();
        showToast("Profile Saved");
        btn.textContent = 'Save Changes';
    };
    
    get('profile-file-input').onchange = async (e) => {
        const f = e.target.files[0]; if(!f) return;
        const reader = new FileReader();
        reader.readAsDataURL(f);
        reader.onload = (ev) => {
            const img = new Image(); img.src = ev.target.result;
            img.onload = async () => {
                const cvs = document.createElement('canvas'); cvs.width=300; cvs.height=300;
                cvs.getContext('2d').drawImage(img,0,0,300,300);
                const url = cvs.toDataURL('image/jpeg',0.8);
                
                // Update local state temporarily so save button picks it up if clicked later
                // But generally users want immediate photo update.
                // Let's update photo immediately in DB + Chats
                
                showToast("Uploading...");
                await updateDoc(doc(db, USERS_PATH, currentUser.uid), { photoURL: url });
                
                // Sync to chats
                const q = query(collection(db, CHATS_PATH), where("participants", "array-contains", currentUser.uid));
                const snaps = await getDocs(q);
                const batch = writeBatch(db);
                snaps.forEach(d => {
                    batch.update(doc(db, CHATS_PATH, d.id), {
                        [`participantInfo.${currentUser.uid}.photoURL`]: url
                    });
                });
                await batch.commit();

                // Update local state and cache
                currentUserData.photoURL = url;
                localStorage.setItem('cached_user_data', JSON.stringify(currentUserData));
                updateHeaderUI();
                showToast("Photo Updated");
            };
        };
    };

    // --- GLOBAL PRESENCE & NOTIFICATIONS (UPDATED FOR BACKGROUND) ---
    function updatePresence(status) {
        if(currentUser) updateDoc(doc(db, USERS_PATH, currentUser.uid), { status: status, lastActive: serverTimestamp() }).catch(()=>{});
    }
    
    // Smart Presence Logic: Don't disconnect immediately on minimize
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Came back to foreground
            if (backgroundDisconnectTimeout) clearTimeout(backgroundDisconnectTimeout);
            updatePresence('online');
            // Force reconnect if needed
            if (wakeLock !== null) requestWakeLock();
        } else {
            // Gone to background - wait 2 mins before marking offline
            backgroundDisconnectTimeout = setTimeout(() => {
                updatePresence('offline');
            }, 2 * 60 * 1000); 
        }
    });
    
    // --- FORCE OFFLINE ON WINDOW CLOSE ---
    window.addEventListener('beforeunload', () => {
        updatePresence('offline');
    });
    
    setInterval(() => {
        if(currentUser && document.visibilityState === 'visible') {
            updatePresence('online');
        }
    }, 60000);

    function listenGlobalMessages() {
        if(globalNotificationUnsubscribe) globalNotificationUnsubscribe();
        const q = query(collection(db, CHATS_PATH), where("participants", "array-contains", currentUser.uid));
        globalNotificationUnsubscribe = onSnapshot(q, (snap) => {
            snap.docChanges().forEach(change => {
                if(change.type === 'modified') {
                    const d = change.doc.data();
                    if(d.lastMessage?.senderId !== currentUser.uid && (Date.now() - (d.updatedAt?.seconds || 0)*1000 < 5000)) {
                         if(document.visibilityState === 'hidden' || currentChatId !== change.doc.id) {
                             // --- SOUND CHECK ---
                             // --- UPDATED: Play Sweet Beep for Notification ---
                             if(isSoundEnabled) {
                                 const audio = document.getElementById('snd-sweet-beep');
                                 if(audio) {
                                     audio.currentTime = 0;
                                     audio.play().catch(e => console.log("Audio permission needed first interaction"));
                                 }
                             }
                             const senderId = d.lastMessage.senderId;
                             const senderProfile = d.participantInfo && d.participantInfo[senderId] ? d.participantInfo[senderId] : { displayName: 'Friend' };
                             const title = senderProfile.displayName;

                             let bodyTxt = d.lastMessage.text;
                             if(d.lastMessage.type === 'image') bodyTxt = ' Sent a photo';
                             else if(d.lastMessage.type === 'video') bodyTxt = ' Sent a video';
                             else if(d.lastMessage.type === 'file') bodyTxt = ' Sent a file';
                             else if(d.lastMessage.type === 'audio') bodyTxt = ' Sent a voice message';

                             if (Notification.permission === "granted") {
                                 const notif = new Notification(title, {
                                     body: bodyTxt,
                                     icon: senderProfile.photoURL || 'https://i.postimg.cc/RZ5FH16z/Gemini-Generated-Image-rgsqsqrgsqsqrgsq-removebg-preview.png',
                                     tag: 'new-msg',
                                     renotify: true,
                                     vibrate: [200, 100, 200],
                                     requireInteraction: false
                                 });
                                 notif.onclick = () => { window.focus(); notif.close(); };
                             }
                         }
                    }
                }
            });
        });
    }
    
    // --- DELETION LOGIC ---
    async function deleteMsg(rid, mid, scope) {
        if(scope === 'everyone') {
             await updateDoc(doc(db, CHATS_PATH, rid, 'messages', mid), { type: 'deleted', text: 'deleted' });
             await updateDoc(doc(db, CHATS_PATH, rid), { 'lastMessage.type': 'deleted', 'lastMessage.text': 'deleted' });
             showToast("Unsent");
        } else {
             await updateDoc(doc(db, CHATS_PATH, rid, 'messages', mid), { deletedFor: arrayUnion(currentUser.uid) });
             showToast("Deleted");
        }
        hideActionSheet();
    }
    
    async function deleteChatForMe(rid) {
        await updateDoc(doc(db, CHATS_PATH, rid), { hiddenFor: arrayUnion(currentUser.uid) });
        hideActionSheet(); showToast("Chat Deleted");
    }

    // --- INSTALL LOGIC ---
    let deferredPrompt;
    const installBanner = document.getElementById('install-banner');
    const installBtn = document.getElementById('install-btn');

    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        installBanner.style.display = 'flex';
    });

    installBtn.addEventListener('click', async () => {
        if (deferredPrompt) {
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            deferredPrompt = null;
            if (outcome === 'accepted') {
                installBanner.style.display = 'none';
            }
        }
    });

    window.addEventListener('appinstalled', () => {
        installBanner.style.display = 'none';
    });
    
    if (window.matchMedia('(display-mode: standalone)').matches) {
        installBanner.style.display = 'none';
    }

  </script>
</body>
</html>